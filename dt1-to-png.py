import glob
import os
import sys
import getopt
from PIL import Image
from ssi_filetypes.dt1file import DT1File
import xml.etree.cElementTree as ET

POSITIVE = "Hyperbola"
NEGATIVE = "Negative"

allowed_types = [POSITIVE, NEGATIVE]

img_dict = {"positive": [],
            "negative": []}

# Number of points to grab around the hyperbola peak
image_width_traces = 15
image_points_above = 1
image_points_below = 15

working_dir = ""
output_dir = os.path.join(working_dir, "output")



def create_output_directory():
    # Create the output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

def get_dt1_list():
    """
    Get a list of DT1s in the specified directory, strip extensions
    :return:
    """
    dt1_files = glob.glob(working_dir + "\*.DT1")
    working_file_list = []
    for dt1_file_path in dt1_files:
        folder, filename = os.path.split(dt1_file_path)
        filename, extension = os.path.splitext(filename)
        print folder, filename, extension

        working_file_list.append(os.path.join(folder, filename))

    return working_file_list


def usage():
    print "Required arguments:"
    print " Working directory; folder containing the DT1, RBA and CSV files"
    print "Optional arguments:"
    print " -h: Display help"
    print " -o: Output directory (defaults to <working directory>\output"
    print " -a: Number of sample points to capture from above the pick (default {})".format(image_points_above)
    print " -b: Number of sample points to capture from below the pick (default {})".format(image_points_below)
    print " -w: Total number of traces to capture, centered on the pick (default {})".format(image_width_traces)


def abort():
    print "Invalid command line arguments"
    usage()
    sys.exit()


if __name__ == "__main__":

    # Parse command line arguments
    COMMAND_LINE_ARGUMENTS = "hw:a:b:o:"
    opts = {}
    args = []
    try:
        opts, args = getopt.getopt(sys.argv[1:], COMMAND_LINE_ARGUMENTS)
    except getopt.GetoptError:
        abort()

    if len(args) > 0:
        working_dir = args[0]
        output_dir = os.path.join(working_dir, "output")
    else:
        abort()

    for opt, arg in opts:
        if opt == "-h":
            usage()
            sys.exit()
        elif opt == "-w":
            image_width_traces = int(arg)
            if image_width_traces % 2:
                image_width_traces += 1
        elif opt == "-a":
            image_points_above = int(arg)
        elif opt == "-b":
            image_points_below = int(arg)
        elif opt == "-o":
            output_dir = arg

    create_output_directory()

    working_file_list = get_dt1_list()

    dt1 = DT1File()
    uid = 0
    for dt1_file_path in working_file_list:

        # Open the DT1 for read
        if dt1.opened:
            dt1.close()
        dt1.open_for_read(dt1_file_path)

        # Check what type of hyperbola data we have to work with, the currently supported types are RBA file (generated
        # by rebar analysis) or CSV file (generated by EKKO_Project's CSV project report)
        pick_array = []

        # Read in any EP csv files, the csv files would normally be in a folder named after the line. The file name would
        # be <linename>_interps.csv
        folder, file_name = os.path.split(dt1_file_path)

        for pick in pick_array:
            x_min, x_max = pick[0] - image_width_traces / 2, pick[0] + image_width_traces / 2
            sample_point = (pick[1] / dt1.time_sampling_interval_ns) + dt1.time_zero_point
            y_min, y_max = sample_point - image_points_above, sample_point + image_points_below

            traces = dt1.get_traces(x_max, 0)[0]
            doi = traces['data']
            doi += 32768
            scale_fact = 255. / (65536)
            doi *= scale_fact
            doi = doi.astype(dtype='uint8')
            img_name = '{}{}_{}.png'.format(dt1.filename, int(pick[0]), uid)
            key = "positive"
            try:
                save_as = os.path.join(output_dir, img_name)
                img_dict[key].append(
                    ' '.join(["./{}_images/".format(key) + img_name, "1", "0", "0", str(len(doi)), str(len(doi[0]))]))
                image = Image.fromarray(doi.transpose())
                image.save(os.path.join(output_dir, img_name))
            except IndexError as e:
                print "Error generating image " + save_as
