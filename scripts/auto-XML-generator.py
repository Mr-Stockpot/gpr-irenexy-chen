import glob
import os
import sys
import getopt
from PIL import Image
from ssi_filetypes.dt1file import DT1File
import xml.etree.cElementTree as ET

POSITIVE = "Hyperbola"
NEGATIVE = "Negative"

allowed_types = [POSITIVE, NEGATIVE]

img_dict = {"positive": [],
            "negative": []}

# Number of points to grab around the hyperbola peak
image_width_traces = 15
image_points_above = 1
image_points_below = 15

working_dir = ""
output_dir = os.path.join(working_dir, "output")



def read_rba_file(file_path):
    """
    :param file_path: Path to the rba file, without extension
    :return: Array of picks, each pick is a trace number, time (ns) and amplitude (mV)
    """
    pick_array = []
    with open(file_path + ".rba", 'r') as rba:

        # Skip the first 5 lines
        for i in xrange(5):
            s = rba.readline()

        # Store the picks in an array
        for line in rba:
            pick_array.append(map(float, line.strip().split(",")))

    return pick_array


def read_EP_csv(file_path, dt1_step_size_m=1.):
    """

    :param  file_path: Path to the csv file generated by EKKO_Project, without extension
            dt1_step_size_m: Step size specified by the DT1 in m, so we can convert position to trace #
    :return: Array of picks, each pick is a trace number, time(ns) and amplitude (mV)
    """
    with open(file_path + "_interps.csv", 'r') as csv:

        # Skip lines until we reach the "Tool" cell, the cell after this is where the data starts
        s = ""
        while not s.lower().startswith("\"tool\""):
            s = csv.readline()

        # Start storing points in the pick array, check for interp type
        for line in csv:
            if line.lower().startswith('\"point\"'):
                parts = line.strip().split(",")
                position_m = float(parts[3])
                time_ns = float(parts[7])
                amplitude_mV = float(parts[9])
                pick_array.append((1 + position_m / dt1_step_size_m, time_ns, amplitude_mV))

    return pick_array


def create_output_directory():
    # Create the output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

def get_dt1_list():
    """
    Get a list of DT1s in the specified directory, strip extensions
    :return:
    """
    dt1_files = glob.glob(working_dir + "\*.DT1")
    working_file_list = []
    for dt1_file_path in dt1_files:
        folder, filename = os.path.split(dt1_file_path)
        filename, extension = os.path.splitext(filename)
        print folder, filename, extension

        working_file_list.append(os.path.join(folder, filename))

    return working_file_list


def usage():
    print "Required arguments:"
    print " Working directory; folder containing the DT1, RBA and CSV files"
    print "Optional arguments:"
    print " -h: Display help"
    print " -o: Output directory (defaults to <working directory>\output"
    print " -a: Number of sample points to capture from above the pick (default {})".format(image_points_above)
    print " -b: Number of sample points to capture from below the pick (default {})".format(image_points_below)
    print " -w: Total number of traces to capture, centered on the pick (default {})".format(image_width_traces)


def abort():
    print "Invalid command line arguments"
    usage()
    sys.exit()


class ScopeProcess():
    def __init__():
        self.img_name = ""
        self.folder = ""
        self.width = 0
        self.height = 0
        self.depth = 1


    def writeXMLs():
        root = ET.Element("annotation")

        ET.SubElement(root, "folder").text = self.img_name
        ET.SubElement(root, "filename").text = self.img_name
        ET.SubElement(root, "path").text = self.img_name

        source = ET.SubElement(root, "source")
        ET.SubElement(source, "database").text = self.folder

        size = ET.SubElement(root, "size")
        ET.SubElement(size, "width").text = self.width
        ET.SubElement(size, "height").text = self.height
        ET.SubElement(size, "depth").text = self.depth

        ET.SubElement(root, "segmented").text = 0

        for obj in hyperbolas: 
            obj = ET.SubElement(root, "object")
            ET.SubElement(obj, "name").text = "hyperbola"
            ET.SubElement(obj, "pose").text = "Unspecified"
            ET.SubElement(obj, "truncated").text = 0
            ET.SubElement(obj, "difficult").text = 0

            bndbox = ET.SubElement(obj, "bndbox")
            ET.SubElement(obj, "xmin").text = xmin
            ET.SubElement(obj, "xmax").text = xmax
            ET.SubElement(obj, "ymin").text = ymin
            ET.SubElement(obj, "ymax").text = ymax

        tree = ET.ElementTree(root)
        tree.write(self.img_name + ".xml")









if __name__ == "__main__":

    # Parse command line arguments
    COMMAND_LINE_ARGUMENTS = "hw:a:b:o:"
    opts = {}
    args = []
    try:
        opts, args = getopt.getopt(sys.argv[1:], COMMAND_LINE_ARGUMENTS)
    except getopt.GetoptError:
        abort()

    if len(args) > 0:
        working_dir = args[0]
        output_dir = os.path.join(working_dir, "output")
    else:
        abort()

    for opt, arg in opts:
        if opt == "-h":
            usage()
            sys.exit()
        elif opt == "-w":
            image_width_traces = int(arg)
            if image_width_traces % 2:
                image_width_traces += 1
        elif opt == "-a":
            image_points_above = int(arg)
        elif opt == "-b":
            image_points_below = int(arg)
        elif opt == "-o":
            output_dir = arg

    create_output_directory()

    working_file_list = get_dt1_list()

    dt1 = DT1File()
    uid = 0
    for dt1_file_path in working_file_list:

        # Open the DT1 for read
        if dt1.opened:
            dt1.close()
        dt1.open_for_read(dt1_file_path)

        # Check what type of hyperbola data we have to work with, the currently supported types are RBA file (generated
        # by rebar analysis) or CSV file (generated by EKKO_Project's CSV project report)
        pick_array = []
        # Read in any rba files, the rba should be in the same directory as the DT1, with extension .rba
        if os.path.isfile(dt1_file_path + ".rba"):
            pick_array += read_rba_file(dt1_file_path)

        # Read in any EP csv files, the csv files would normally be in a folder named after the line. The file name would
        # be <linename>_interps.csv
        folder, file_name = os.path.split(dt1_file_path)
        if os.path.isfile(os.path.join(dt1_file_path, file_name + "_interps.csv")):
            pick_array += read_EP_csv(os.path.join(dt1_file_path, file_name), dt1.step_size_m)


        for pick in pick_array:
            x_min, x_max = pick[0] - image_width_traces / 2, pick[0] + image_width_traces / 2
            sample_point = (pick[1] / dt1.time_sampling_interval_ns) + dt1.time_zero_point
            y_min, y_max = sample_point - image_points_above, sample_point + image_points_below

            traces = dt1.get_traces(int(x_max - x_min), int(x_min))[0]
            doi = traces['data'][:, int(y_min):int(y_max)]
            doi += 32768
            scale_fact = 255. / (65536)
            doi *= scale_fact
            doi = doi.astype(dtype='uint8')
            img_name = '{}{}_{}.png'.format(dt1.filename, int(pick[0]), uid)
            key = "positive"
            try:
                save_as = os.path.join(output_dir, img_name)
                img_dict[key].append(
                    ' '.join(["./{}_images/".format(key) + img_name, "1", "0", "0", str(len(doi)), str(len(doi[0]))]))
                image = Image.fromarray(doi.transpose())
                image.save(os.path.join(output_dir, img_name))
            except IndexError as e:
                print "Error generating image " + save_as
